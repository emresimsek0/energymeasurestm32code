/* Includes başlık dosyaları tanımlanıyor.
#include "main.h"
uint32_t gerilimoku; //Kanal 0 (A0) üzerinden okunan ADC sinyalinin sayısal 
değerinin depolanacağı değişken.
uint32_t akimoku;//Kanal 1 (A1) üzerinden okunan ADC sinyalinin sayısal değerinin 
depolanacağı değişken.
ADC_ChannelConfTypeDef sConfigPrivate = {0}; // STRUCT tanımlanıyor bu struct içerisinde ADC parametrelerini içeriyor. 
/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
//Programın ayarladığı default ayarlar, örneğin sistem saati, giriş ve çıkışlar ve analog sayısal dönüştürücü fonksiyonu
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);

void adcoku() //ADC nin tanımlandığı fonksiyon
{
 sConfigPrivate.Rank = ADC_REGULAR_RANK_1; // Daha önceden tanımlanan struct rank elemanı çağrılıyor bunun nedeni ADC Rank1 de okunacak
 sConfigPrivate.SamplingTime = ADC_SAMPLETIME_1CYCLE_5; //TADC = TSAMPLİNG + TCONVERSİON olursa TSAMPLİNG = 5 cycle  oluyor. TSAMPLİNG ne kadar küçük ise, TADC o kadar küçülür.
sConfigPrivate.Channel = ADC_CHANNEL_0; //
 HAL_ADC_ConfigChannel(&hadc1, &sConfigPrivate);
 HAL_ADC_Start(&hadc1);
 HAL_ADC_PollForConversion(&hadc1,1000);
 gerilimoku = HAL_ADC_GetValue(&hadc1); //A0 pininden okunan gerilim 
değerinin depolandığı değişken
 HAL_ADC_Stop(&hadc1);
 sConfigPrivate.Channel = ADC_CHANNEL_1;
 HAL_ADC_ConfigChannel(&hadc1, &sConfigPrivate);
 HAL_ADC_Start(&hadc1);
 HAL_ADC_PollForConversion(&hadc1,1000);
 akimoku = HAL_ADC_GetValue(&hadc1);//A1 pininden okunan gerilim 
değerinin depolandığı değişken
 HAL_ADC_Stop(&hadc1); /* Tanımlanan hadc1 isimli ADC okuyucu durdurulsun çünkü başka veri alınmasın.
}
/* USER CODE END 0 */
/**
 * @brief The application entry point.
 * @retval int
 */
int main(void)
{
 /* USER CODE BEGIN 1 */
uint8_t i;//String değişkenlerin her bir karakterini gezmesi için kullanılacak 
değişken
//LCD görüntülenmesi gereken bazı kelimeler
uint8_t gerilim[] = {"gerilim"};
uint8_t akim[] = {"akim"};
uint8_t okunamadi[] = {"okunamadi"};
uint8_t degeri[] = {"degeri"};
 /* USER CODE END 1 */
 /* MCU Configuration--------------------------------------------------------*/
 /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 HAL_Init();
 /* USER CODE BEGIN Init */
 /* USER CODE END Init */
 /* Configure the system clock */
 SystemClock_Config();
 /* USER CODE BEGIN SysInit */
 /* USER CODE END SysInit */
 /* Initialize all configured peripherals */
 MX_GPIO_Init();
 MX_ADC1_Init();
 /* USER CODE BEGIN 2 */
 LCD_init(); //LCD fonksiyonu çağrılıyor
 /* USER CODE END 2 */
 /* Infinite loop */
 /* USER CODE BEGIN WHILE */
 while (1)
 {
 /* USER CODE END WHILE */
 /* USER CODE BEGIN 3 */
 HAL_ADC_Start(&hadc1);
 //LCD(0x01,0);
 adcoku(); //adcoku fonksiyonu çağrılarak ADC değerleri ilgili değişkenlere 
depolanır.
 LCD(0x81,0); //LCD 1.satırı kullanılır.
 for(i = 0;i<7;i++)
 {
 LCD(gerilim[i],1);
}
 LCD(0xC1,0); //LCD 2.satırı kullanılır.
 gerilimhesapla(gerilimoku);
 LCD(0x95,0); //LCD 3.satırı kullanılır.
 for(i = 0;i<7;i++)
 {
 LCD(akim[i],1);
 }
 LCD(0xD5,0); //LCD 4.satırı kullanılır.
 akimhesapla(akimoku); //akimin gerçek değeri görüntülenir.
 HAL_ADC_Stop(&hadc1); //ADC durdurulur.
 }
 }
void SystemClock_Config(void)
{
 RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 /** Initializes the RCC Oscillators according to the specified parameters
 * in the RCC_OscInitTypeDef structure.
 */
 RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 RCC_OscInitStruct.HSICalibrationValue = 
RCC_HSICALIBRATION_DEFAULT;
 RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 {
 Error_Handler();
 }
 /** Initializes the CPU, AHB and APB buses clocks
 */
 RCC_ClkInitStruct.ClockType = 
RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
 RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != 
HAL_OK)
 {
 Error_Handler();
 }
 PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
 PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;
 if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 {
 Error_Handler();
 }
}
/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{
 /* USER CODE BEGIN ADC1_Init 0 */
 /* USER CODE END ADC1_Init 0 */
 ADC_ChannelConfTypeDef sConfig = {0};
 /* USER CODE BEGIN ADC1_Init 1 */
 /* USER CODE END ADC1_Init 1 */
 /** Common config
 */
 hadc1.Instance = ADC1;
 hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 hadc1.Init.ContinuousConvMode = ENABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
 hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 hadc1.Init.NbrOfConversion = 1;
 if (HAL_ADC_Init(&hadc1) != HAL_OK)
 {
 Error_Handler();
 }
 /** Configure Regular Channel
 */
 sConfig.Channel = ADC_CHANNEL_0;
 sConfig.Rank = ADC_REGULAR_RANK_1;
 sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 {
 Error_Handler();
 }
 /* USER CODE BEGIN ADC1_Init 2 */
 /* USER CODE END ADC1_Init 2 */
}
/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
 GPIO_InitTypeDef GPIO_InitStruct = {0};
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */
 /* GPIO Ports Clock Enable */
 __HAL_RCC_GPIOA_CLK_ENABLE();
 __HAL_RCC_GPIOB_CLK_ENABLE();
 /*Configure GPIO pin Output Level */
 HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8, 
GPIO_PIN_RESET);
 /*Configure GPIO pin Output Level */
 HAL_GPIO_WritePin(GPIOB, 
GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7, 
GPIO_PIN_RESET);
 /*Configure GPIO pins : PA6 PA7 PA8 */
GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 GPIO_InitStruct.Pull = GPIO_NOPULL;
 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 /*Configure GPIO pins : PB0 PB1 PB2 PB3
 PB4 PB5 PB6 PB7 */
 GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 GPIO_InitStruct.Pull = GPIO_NOPULL;
 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 /*Configure GPIO pins : PA14 PA15 */
 GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
 GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 GPIO_InitStruct.Pull = GPIO_PULLUP;
 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
/* USER CODE BEGIN 4 */
void LCD_init(void) //LCD yazılımsal kodları
{
LCD(0x38,0);
LCD(0x0C,0);
LCD(0x06,0);
LCD(0x01,0);
LCD(0x80,0);
}
void LCD(uint8_t val_1,uint8_t cmd) //LCD donanım olarak bağlantısı
{
uint8_t data1;
HAL_GPIO_WritePin(GPIOA,GPIO_PIN_6,cmd);
data1 = val_1 & 0x01;
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,data1);
data1 = (val_1>>1) & 0x01;
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,data1);
data1 = (val_1>>2) & 0x01;
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,data1);
data1 = (val_1>>3) & 0x01;
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_3,data1);
data1 = (val_1>>4) & 0x01;
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_4,data1);
data1 = (val_1>>5) & 0x01;
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,data1);
data1 = (val_1>>6) & 0x01;
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,data1);
data1 = (val_1>>7) & 0x01;
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_7,data1);
//enable pulse
HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,GPIO_PIN_SET);
HAL_Delay(5);
HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,GPIO_PIN_RESET);
}
void gerilimhesapla(uint32_t gelendeger) //0 ile 4096 arasındaki gelen sayıyı 
dönüştüren fonksiyon
{
uint32_t analog;
uint32_t analog1;
uint32_t analog2;
uint32_t analog3;
uint32_t analog4;
uint32_t analogo;
uint32_t analogi;
uint32_t gunc;
uint32_t gunc1;
analog = (gelendeger);
analog1 = 1222*(analog/1000); //Binler basamağı
analog2 = 122*((analog/100)%10);//Yüzler basamağı
analog3 = 12*((analog/10)%10); // onlar basamağı
analog4 = 1*((analog/1)%10);//birler basamağı
analogo = analog1+analog2+analog3+analog4;//0 ile 5000 aralığına 
ulaşılır
 gunc = ((analogo*10) -1600)/208;
 gunc1 = gunc + 40; //gerçek gerilim değerine ulaşılır.
analogi = ((gunc1/1000));
LCD(0x9C,0);
LCD((analogi+48),1);
analogi = ((gunc1/100)%10);
LCD((analogi+48),1);
analogi = ((gunc1/10)%10);
LCD((analogi+48),1);
analogi = ((gunc1)%10);
LCD((analogi+48),1);
}
void akimhesapla(uint32_t gelendeger) //0 ile 4096 arasındaki gelen sayıyı 
dönüştüren fonksiyon
{
uint32_t analog;
uint32_t analog1;
uint32_t analog2;
uint32_t analog3;
uint32_t analog4;
uint32_t analogo;
uint32_t analogi;
uint32_t gunc;
uint32_t gunc1;
analog = (gelendeger);
analog1 = 1222*(analog/1000); //Binler basamağı
analog2 = 122*((analog/100)%10);//Yüzler basamağı
analog3 = 12*((analog/10)%10);//Onlar basamağı
analog4 = 1*((analog/1)%10);//Birler basamağı
analogo = analog1+analog2+analog3+analog4;//0 ile 5000 arasındaki 
değere dönüştürülür.
 gunc = (analogo-2500); //0A 2.5V başladığı için değer 2500 çıkarılır.
 gunc1 = gunc*30/2000; //0ile 30A 0 ile 2000 arasında ifade edilir.
analogi = ((gunc1/1000));
LCD(0xDC,0);
LCD((analogi+48),1);
analogi = ((gunc1/100)%10);
LCD((analogi+48),1);
analogi = ((gunc1/10)%10);
LCD((analogi+48),1);
analogi = ((gunc1)%10);
LCD((analogi+48),1);
}
